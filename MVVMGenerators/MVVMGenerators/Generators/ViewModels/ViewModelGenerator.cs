using System.Threading;
using System.Diagnostics;
using Microsoft.CodeAnalysis;
using MVVMGenerators.Helpers;
using System.Collections.Generic;
using MVVMGenerators.Descriptions;
using Microsoft.CodeAnalysis.CSharp;
using System.Runtime.CompilerServices;
using MVVMGenerators.Extensions.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MVVMGenerators.Extensions.Declarations;

namespace MVVMGenerators.Generators.ViewModels;

[Generator(LanguageNames.CSharp)]
public class ViewModelGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(SyntacticPredicate, FindViewModels)
            .Where(foundForSourceGenerator => foundForSourceGenerator.IsNeed)
            .Select((foundForSourceGenerator, _) => foundForSourceGenerator.Container);
        
        context.RegisterSourceOutput(
            source: provider,
            action: GenerateCode);
    }
    
    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        var candidate = node switch
        {
            ClassDeclarationSyntax or StructDeclarationSyntax => node as TypeDeclarationSyntax,
            _ => null
        };
    
        return candidate is not null
            && candidate.AttributeLists.Count > 0
            && candidate.Modifiers.Any(SyntaxKind.PartialKeyword)
            && !candidate.Modifiers.Any(SyntaxKind.StaticKeyword);
    }
    
    private static FoundForGenerator<ViewModelData> FindViewModels(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        Debug.Assert(context.Node is TypeDeclarationSyntax);
        var candidate = Unsafe.As<TypeDeclarationSyntax>(context.Node);
        if (!candidate.HasAttribute(context.SemanticModel, Classes.ViewModelAttribute.FullName)) return default;

        var symbol = context.SemanticModel.GetDeclaredSymbol(candidate, cancellationToken);
        if (symbol is null) return default;
    
        var fields = new List<IFieldSymbol>();
        var methods = new List<IMethodSymbol>();
    
        foreach (var member in symbol.GetMembers())
        {
            switch (member)
            {
                case IFieldSymbol field:
                    if (field.HasAttribute(Classes.BindAttribute.FullName)) 
                        fields.Add(field);
                    break;
                
                case IMethodSymbol method: 
                    if (method.HasAttribute("UltimateUI.MVVM.ViewModels.BindCommandAttribute")) 
                        methods.Add(method);
                    break;
            }
        }

        var hasBaseType = false; 
        var hasInterface = symbol.HasInterface(Classes.IViewModel.FullName);
        
        for (var type = symbol.BaseType; type != null; type = type.BaseType)
        {
            if (type.HasInterface(Classes.IViewModel.FullName))
                hasInterface = true;
            
            if (type.HasAttribute(Classes.ViewModelAttribute.FullName))
                hasBaseType = true;
            
            if (hasInterface && hasBaseType) break;
        }
        
        return new FoundForGenerator<ViewModelData>(true, 
            new ViewModelData(hasBaseType, hasInterface, candidate, fields, methods));
    }
    
    private static void GenerateCode(SourceProductionContext context, ViewModelData viewModel)
    {
        var declaration = viewModel.Declaration;
        var namespaceName = declaration.GetNamespaceName();
        var declarationText = declaration.GetDeclarationText();

        GenerateProperties(context, namespaceName, declarationText, viewModel);
        GenerateGetBinds(context, namespaceName, declarationText, viewModel);
    }

    private static void GenerateProperties(SourceProductionContext context, string namespaceName,
        DeclarationText declarationText, ViewModelData viewModel)
    {
        if (viewModel.Fields.Count == 0) return;
         
        var code = new CodeWriter();
        code.AppendLine("// <auto-generated>");
        
        if (!string.IsNullOrEmpty(namespaceName))
        {
            code.AppendLine($"namespace {namespaceName}")
                .BeginBlock();   
        }
        
        code.AppendLine($"{declarationText}")
            .BeginBlock();
        code.AppendViewModelProperties(viewModel.Fields);
        code.EndBlock();
        
        if (!string.IsNullOrEmpty(namespaceName))
            code.EndBlock();
        
        context.AddSource($"{declarationText.Name}.BindProperty.Generated.cs", code.GetSourceText());
    }
    
    private static void GenerateGetBinds(SourceProductionContext context, string namespaceName,
        DeclarationText declarationText, ViewModelData viewModel)
    {
        if (viewModel.Fields.Count == 0 &&
            viewModel.HasViewModelBaseType) return;
        
        var code = new CodeWriter();
        code.AppendLine("// <auto-generated>");
        
        if (!string.IsNullOrEmpty(namespaceName))
        {
            code.AppendLine($"namespace {namespaceName}")
                .BeginBlock();   
        }

        code.Append($"{declarationText}");

        var isIViewModelGenerate = viewModel is { HasViewModelInterface: false, HasViewModelBaseType: false };
        if (isIViewModelGenerate)
            code.Append($" : {Classes.IViewModel.Global}");
        
        code.AppendLine()
            .BeginBlock()
            .AppendGetBindMethods(viewModel.HasViewModelBaseType, viewModel.HasViewModelInterface, viewModel.Fields)
            .EndBlock();
        
        if (!string.IsNullOrEmpty(namespaceName))
            code.EndBlock();
        
        context.AddSource($"{declarationText.Name}.IViewModel.Generated.cs", code.GetSourceText());
    }
}