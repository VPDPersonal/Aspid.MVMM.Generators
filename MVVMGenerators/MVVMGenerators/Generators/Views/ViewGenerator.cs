using System;
using System.Linq;
using System.Threading;
using System.Diagnostics;
using Microsoft.CodeAnalysis;
using MVVMGenerators.Helpers;
using System.Collections.Generic;
using MVVMGenerators.Descriptions;
using Microsoft.CodeAnalysis.CSharp;
using System.Runtime.CompilerServices;
using MVVMGenerators.Extensions.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MVVMGenerators.Extensions.Declarations;

namespace MVVMGenerators.Generators.Views;

[Generator(LanguageNames.CSharp)]
public class ViewGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(SyntacticPredicate, FindViews)
            .Where(foundForSourceGenerator => foundForSourceGenerator.IsNeed)
            .Select((foundForSourceGenerator, _) => foundForSourceGenerator.Container);
        
        context.RegisterSourceOutput(
            source: provider,
            action: GenerateCode);
    }

    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        var candidate = node switch
        {
            ClassDeclarationSyntax or StructDeclarationSyntax => node as TypeDeclarationSyntax,
            _ => null
        };

        return candidate is not null
            && candidate.Modifiers.Any(SyntaxKind.PartialKeyword)
            && !candidate.Modifiers.Any(SyntaxKind.StaticKeyword)
            && candidate.AttributeLists.Count > 0;
    }

    private static FoundForGenerator<ViewData> FindViews(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        Debug.Assert(context.Node is TypeDeclarationSyntax);
        var candidate = Unsafe.As<TypeDeclarationSyntax>(context.Node);
        if (!candidate.HasAttribute(context.SemanticModel, Classes.ViewAttribute.FullName)) return default;

        var symbol = context.SemanticModel.GetDeclaredSymbol(candidate, cancellationToken);
        if (symbol is null) return default;

        var fields = new List<IFieldSymbol>();
        foreach (var field in symbol.GetMembers().OfType<IFieldSymbol>())
        {
            if (field.Type is IArrayTypeSymbol arrayTypeSymbol 
                && arrayTypeSymbol.ElementType.HasInterface(Classes.IBinder))
            {
                fields.Add(field);
            }
            else if (field.Type.HasInterface(Classes.IBinder))
            {
                fields.Add(field);
            }
        }
        
        if (!fields.Any()) return default;
        
        var inheritor = ViewInheritor.None;

        for (var type = symbol.BaseType; type != null; type = type.BaseType)
        {
            if (!type.HasAttribute(Classes.ViewAttribute.FullName)) continue;
            
            inheritor = ViewInheritor.InheritorViewAttribute;
            return new FoundForGenerator<ViewData>(true, new ViewData(symbol, inheritor, candidate, fields));
        }
        
        if (symbol.HasBaseType(Classes.MonoView))
        {
            inheritor = ViewInheritor.InheritorMonoView;
            
            foreach (var method in symbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (!method.IsOverride) continue;
                if (method.DeclaredAccessibility != Accessibility.Protected) continue;
                if (method.Parameters.Length != 0) continue;
                if (method.Name != "GetBinders") continue;
                if (method.ReturnType.ToDisplayString() != Classes.IReadOnlyBindersCollectionById.FullName) continue;

                inheritor = ViewInheritor.OverrideMonoView;
                break;
            }
        }
        else if (symbol.HasInterface(Classes.IView))
        {
            inheritor = ViewInheritor.HasInterface;
        }

        return new FoundForGenerator<ViewData>(true, new ViewData(symbol, inheritor, candidate, fields));
    }
    
    private static void GenerateCode(SourceProductionContext context, ViewData viewData)
    {
        var declaration = viewData.Declaration;
        var namespaceName = declaration.GetNamespaceName();
        var declarationText = declaration.GetDeclarationText();
        
        var code = new CodeWriter();
        code.AppendLine("// <auto-generated>");
        
        if (!string.IsNullOrEmpty(namespaceName))
        {
            code.AppendLine($"namespace {namespaceName}")
                .BeginBlock();   
        }
        
        if (viewData.Inheritor == ViewInheritor.None)
        {
            code.AppendLine($"{declarationText} : {Classes.IView.Global}")
                .BeginBlock();
        }
        else
        {
            code.AppendLine($"{declarationText}")
                .BeginBlock(); 
        }
        
        switch (viewData.Inheritor)
        {
            case ViewInheritor.InheritorViewAttribute:
                code.AppendMultiline(
                    $$"""
                      protected override {{Classes.BindersCollectionById.Global}} GetBindersIternal()
                      {
                          var binders = base.GetBindersIternal(); 
                          
                      """).IncreaseIndent();
                break;
            
            case ViewInheritor.None:
                code.AppendMultiline(
                    $"""
                    {Classes.IReadOnlyBindersCollectionById.Global} {Classes.IView.Global}.GetBinders() =>
                        GetBindersIternal();

                    """);
                goto case ViewInheritor.OverrideMonoView;
            
            case ViewInheritor.InheritorMonoView:
                code.AppendMultiline(
                    $"""
                    protected sealed override {Classes.IReadOnlyBindersCollectionById.Global} GetBinders() =>
                        GetBindersIternal();
                    
                    """);
                goto case ViewInheritor.OverrideMonoView;
            
            case ViewInheritor.HasInterface:
            case ViewInheritor.OverrideMonoView: 
                code.AppendMultiline(
                    $$"""
                    protected virtual {{Classes.BindersCollectionById.Global}} GetBindersIternal()
                    {
                        var binders = new {{Classes.BindersCollectionById.Global}}
                        {
                    """)
                    .IncreaseIndent()
                    .IncreaseIndent();
                break;
            
            default: throw new ArgumentOutOfRangeException();
        }

        if (viewData.Inheritor is ViewInheritor.None or ViewInheritor.InheritorMonoView
            or ViewInheritor.OverrideMonoView or ViewInheritor.HasInterface)
        {
            foreach (var field in viewData.Fields)
            {
                code.AppendLine(field.Type.Kind != SymbolKind.ArrayType ?
                    $"{{ \"{field.GetPropertyName()}\", new[] {{ {field.Name} }} }}," :
                    $"{{ \"{field.GetPropertyName()}\", {field.Name} }},");
            }
            
            code.DecreaseIndent()
                .AppendLine("};")
                .AppendLine();

            code.AppendMultiline(
                """
                AddBinders(ref binders);
                return binders;
                """);
        }
        else
        {
            foreach (var field in viewData.Fields)
            {
                code.AppendLine(field.Type.Kind != SymbolKind.ArrayType ?
                    $"binders.Add(\"{field.GetPropertyName()}\", new[] {{ {field.Name} }});" :
                    $"binders.Add(\"{field.GetPropertyName()}\", {field.Name});");
            }
            
            code.AppendLine()
                .AppendMultiline(
                """
                AddBinders(ref binders);
                return binders;
                """);
        }

        code.EndBlock();
        code.AppendLine();
        code.AppendLine($"partial void AddBinders(ref {Classes.BindersCollectionById.Global} binders);");

        // foreach (var field in viewData.Symbol.GetMembers().OfType<IFieldSymbol>())
        // {
        //     code.AppendLine($"{field.Type.ToDisplayString()}")
        //         .BeginBlock();
        //
        //     foreach (var @interface in field.Type.AllInterfaces)
        //     {
        //         code.AppendLine($"{@interface.ToDisplayString()}");
        //     }
        //
        //     code.EndBlock();
        //     code.AppendLine();
        // }
            
            
        code.EndBlock();
        
        if (!string.IsNullOrEmpty(namespaceName))
            code.EndBlock();
            
        context.AddSource($"{declarationText.Name}.IView.Generated.cs", code.GetSourceText());

    }
    
    private readonly struct ViewData(
        INamedTypeSymbol symbol,
        ViewInheritor inheritor,
        TypeDeclarationSyntax declaration,
        IReadOnlyCollection<IFieldSymbol> fields)
    {
        public readonly INamedTypeSymbol Symbol = symbol;
        public readonly ViewInheritor Inheritor = inheritor;
        public readonly TypeDeclarationSyntax Declaration = declaration;
        public readonly IReadOnlyCollection<IFieldSymbol> Fields = fields;

    }
    
    public enum ViewInheritor
    {
        None,
        InheritorViewAttribute, // Наследует ViewAttribute
        
        InheritorMonoView, // Наследует MonoView
        OverrideMonoView, // Наследует MonoView с переопределением методов
        
        HasInterface, // Реализует интерфейс
    }
}